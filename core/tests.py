from django.test import TestCase
from django.contrib.auth.models import User
from django.core.files.uploadedfile import SimpleUploadedFile
from django.utils import timezone
from .models import UploadedFile, UserKeyPair
from .utils import sign_message, decrypt_key, verify_signature
import base64

class DigitalSignatureTests(TestCase):
    def setUp(self):
        self.user = User.objects.create_user(username='testuser', password='password')
        # Keys are automatically generated by signal

    def test_key_generation(self):
        key_pair = UserKeyPair.objects.get(user=self.user)
        self.assertIsNotNone(key_pair.public_key)
        self.assertIsNotNone(key_pair.private_key_encrypted)

    def test_upload_file(self):
        file = SimpleUploadedFile("test_file.txt", b"file_content")
        uploaded_file = UploadedFile.objects.create(owner=self.user, uploaded_file=file)
        self.assertEqual(uploaded_file.owner, self.user)
        self.assertIsNone(uploaded_file.signed_at)

    def test_sign_and_verify_with_timestamp(self):
        # Simulate signing process
        key_pair = UserKeyPair.objects.get(user=self.user)
        decrypted_private_key = decrypt_key(key_pair.private_key_encrypted)

        file_content = b"This is a test document."
        signed_at = timezone.now()
        timestamp_str = signed_at.isoformat()

        # Message construction logic from views.py
        message = file_content + timestamp_str.encode('utf-8')

        signature_bytes = sign_message(decrypted_private_key, message)
        signature_base64 = base64.b64encode(signature_bytes).decode('utf-8')

        # Verify process
        public_key_bytes = key_pair.public_key.encode('utf-8')
        decoded_signature = base64.b64decode(signature_base64)

        # Verify with correct timestamp
        message_to_verify = file_content + timestamp_str.encode('utf-8')
        is_valid = verify_signature(public_key_bytes, message_to_verify, decoded_signature)
        self.assertTrue(is_valid)

        # Verify with incorrect timestamp
        wrong_timestamp = "2020-01-01T00:00:00+00:00"
        message_wrong = file_content + wrong_timestamp.encode('utf-8')
        is_valid_wrong = verify_signature(public_key_bytes, message_wrong, decoded_signature)
        self.assertFalse(is_valid_wrong)

        # Verify without timestamp (legacy check simulation)
        is_valid_legacy = verify_signature(public_key_bytes, file_content, decoded_signature)
        self.assertFalse(is_valid_legacy)

